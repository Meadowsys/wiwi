//! Fast and efficient implementation of Z85, but with nonstandard padding
//! implemented, as the Z85 spec does not account for padding.
//!
//! ## Nonstandard padding implementation
//!
//! Encoding: If padding is needed, the amount of padding that was added in bytes
//! is encoded (ex. 1B padding -> `1` since `TABLE_ENCODER[1] == b'1'`)
//! and appended to the end of the string. (1 extra byte)
//!
//! Decoding: If the len of the slice passed is one more than a multiple of 5
//! (ie. `(n * 5) + 1`), it is trimmed off the slice, decoded to get amount of
//! padding needed, and held onto. Then while decoding the last frame, we take
//! that stored amount of padding, and remove that amount from the end of the
//! decoded bytes.
//!
//! Original Z85 spec: https://rfc.zeromq.org/spec/32

use ::std::{ ptr, slice };

pub const TABLE_ENCODER_LEN: usize = 85;
pub const TABLE_ENCODER: [u8; TABLE_ENCODER_LEN] = *b"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#";
//                                                    0123456789          0123456789          0123456789          0123456789          01234
//                                                              0123456789          0123456789          0123456789          0123456789
//                                                    0         10        20        30        40        50        60        70        80

pub const TABLE_DECODER_LEN: usize = 256;
// generated by `generate-z85-table-decoder`, a binary in this crate
pub const TABLE_DECODER: [Option<u8>; TABLE_DECODER_LEN] = [
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       Some(0x44), None,       Some(0x54), Some(0x53), Some(0x52), Some(0x48), None,       Some(0x4b), Some(0x4c), Some(0x46), Some(0x41), None,       Some(0x3f), Some(0x3e), Some(0x45),
	Some(0x00), Some(0x01), Some(0x02), Some(0x03), Some(0x04), Some(0x05), Some(0x06), Some(0x07), Some(0x08), Some(0x09), Some(0x40), None,       Some(0x49), Some(0x42), Some(0x4a), Some(0x47),
	Some(0x51), Some(0x24), Some(0x25), Some(0x26), Some(0x27), Some(0x28), Some(0x29), Some(0x2a), Some(0x2b), Some(0x2c), Some(0x2d), Some(0x2e), Some(0x2f), Some(0x30), Some(0x31), Some(0x32),
	Some(0x33), Some(0x34), Some(0x35), Some(0x36), Some(0x37), Some(0x38), Some(0x39), Some(0x3a), Some(0x3b), Some(0x3c), Some(0x3d), Some(0x4d), None,       Some(0x4e), Some(0x43), None,
	None,       Some(0x0a), Some(0x0b), Some(0x0c), Some(0x0d), Some(0x0e), Some(0x0f), Some(0x10), Some(0x11), Some(0x12), Some(0x13), Some(0x14), Some(0x15), Some(0x16), Some(0x17), Some(0x18),
	Some(0x19), Some(0x1a), Some(0x1b), Some(0x1c), Some(0x1d), Some(0x1e), Some(0x1f), Some(0x20), Some(0x21), Some(0x22), Some(0x23), Some(0x4f), None,       Some(0x50), None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,
	None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None,       None
];

pub const BINARY_FRAME_LEN: usize = 4;
pub const STRING_FRAME_LEN: usize = 5;

/// Encodes a slice of bytes into a Z85 string, adding padding if necessary
pub fn encode_z85(bytes: &[u8]) -> String {
	// we *don't* fast path out on zero bytes, because in like, 99% of situations,
	// the input is not 0 length, lol. if it were, frames and remainder would be 0,
	// capacity would end up 0 (so no allocation is made), the first loop wouldn't
	// run, the remainder if block wouldn't run, debug_assert's pass, and String is
	// created from empty Vec (empty string, no allocation too). so all is good
	// functionality wise, and its still a fairly fast exit too, I think.

	// right shift 2 is same as integer divide by 4 (BINARY_FRAME_LEN)
	let frames = bytes.len() >> 2;

	// binary AND with 0b11 (3) is the same as modulo 4 (BINARY_FRAME_LEN)
	let remainder = bytes.len() & 0b11;

	// preallocate exact amount of memory needed.
	let capacity = if remainder == 0 {
		frames * STRING_FRAME_LEN
	} else {
		// frames is number of *whole* frames so the remainder is not included by default.
		// adding 1 to allocate space for a whole frame for it.
		let capacity = (frames + 1) * STRING_FRAME_LEN;
		// don't forget that last byte that encodes amount of padding
		capacity + 1
	};

	let mut frames_iter = ChunkedSlice::<BINARY_FRAME_LEN> { bytes };
	let mut dest = Vec::with_capacity(capacity);

	for _ in 0..frames {
		unsafe {
			// SAFETY: everything has been calculated:
			// frames, so we'll have enough bytes left for next full frame
			// - dest, we preallocated all the capacity we need up front
			let frame = frames_iter.next_frame_unchecked();
			encode_frame(frame, &mut dest);
		}
	}

	if remainder > 0 {
		unsafe {
			let data_len = frames_iter.with_remainder_unchecked(|remainder| {
				// SAFETY: everything has been calculated:
				// - remainder, so 0 < remainder < N will be true
				// - dest, we preallocated enough for the remainder up front
				encode_frame(remainder, &mut dest);
			});
			let padding_len = BINARY_FRAME_LEN - data_len;

			// SAFETY: 0 < padding_len < 4 will always be true, which
			// fits in TABLE_ENCODER_LEN
			let padding_char = *TABLE_ENCODER.get_unchecked(padding_len);
			dest.push(padding_char);
		}
	}

	debug_assert_eq!(capacity, dest.capacity(), "allocated enough capacity");
	debug_assert_eq!(capacity, dest.len(), "all allocated capacity is used");
	debug_assert!(String::from_utf8(dest.clone()).is_ok(), "output bytes are valid utf-8");

	// SAFETY: we only are pushing in chars in the table, which are all ASCII chars
	unsafe { String::from_utf8_unchecked(dest) }
}

/// Decodes a slice of of a Z85 string back into the source bytes
pub fn decode_z85(mut bytes: &[u8]) -> Result<Vec<u8>, DecodeError> {
	// this "fast path" isn't here because its beneficial, it's here because
	// it's needed it gets rid of the zero len, which is helpful for later.
	if bytes.is_empty() { return Ok(Vec::new()) }

	// we already returned on empty input. (empty bytes <-> empty string)
	// the next smallest byte len is 1, which would be padded to a full frame
	// and had the amount of padding appended as one more byte. At one frame, it
	// would just be the frame without any padding amount byte added. so therefore
	// the smallest non-zero len is 5.
	if bytes.len() < STRING_FRAME_LEN { return Err(DecodeError::InvalidLength) }

	// at this point, bytes.len() >= STRING_FRAME_LEN

	// this is at least 1
	let frames = bytes.len() / STRING_FRAME_LEN;
	debug_assert!(frames >= 1, "condition of \"at least one frame in input\" was checked correctly");

	let remainder = bytes.len() % STRING_FRAME_LEN;

	// left shift 2 is the same as multiply by 4 (BINARY_FRAME_LEN)
	let capacity = frames << 2;

	let (capacity, added_padding) = match remainder {
		0 => {
			// no padding was added
			(capacity, 0usize)
		}
		1 => {
			// the singular padding byte (there will never be more)
			let added_padding = unsafe {
				// SAFETY: remainder is at least 1, so there
				// will be at least 1 byte in the slice
				let len = bytes.len() - 1;

				let ptr = bytes as *const [u8] as *const u8;
				let byte = *(ptr.add(len));

				bytes = slice::from_raw_parts(ptr, len);

				// SAFETY: 0 <= n < 256 is always true for a u8, and TABLE_DECODER is len 256,
				// so this is safe
				let decoded = *TABLE_DECODER.get_unchecked(byte as usize);

				match decoded {
					Some(val) if (val as usize) < BINARY_FRAME_LEN => { val }
					Some(_) | None => { return Err(DecodeError::InvalidChar) }
				}
			} as usize;

			(capacity - added_padding, added_padding)
		}
		_n => { return Err(DecodeError::InvalidLength) }
	};

	// because frames >= 1, this will be >= 0.
	let excluding_last_frame = frames - 1;

	let mut frames_iter = ChunkedSlice::<STRING_FRAME_LEN> { bytes };
	let mut dest = Vec::with_capacity(capacity);

	for _ in 0..excluding_last_frame {
		unsafe {
			// SAFETY: everything has been calculated:
			// - excluding_last_frame, so we'll always be in bounds of bytes
			//   as well as not touch the last frame
			// - dest, we preallocated all the capacity we need up front

			let frame = frames_iter.next_frame_unchecked();
			decode_frame(frame, |frame| extend_unchecked_const(&mut dest, frame))?;
		}
	}

	// the last frame, this is where the padding is handled
	unsafe {
		let frame = frames_iter.next_frame_unchecked();
		decode_frame(frame, |frame| {
			// - if 0 bytes of padding were added, this is whole frame and
			//   added_padding would be 0
			// - if 0 < n < 4 bytes of padding were added, this is correct
			// - if 4 <= n bytes of "padding" were added, this should have been
			//   either be 0 or 0 < n < 4
			// this is checked up at the top, where the padding amount is decoded

			// so because of all that, this will also be in range of 0 <= n < BINARY_FRAME_LEN
			let non_padding_bytes = BINARY_FRAME_LEN - added_padding;
			debug_assert!(non_padding_bytes <= BINARY_FRAME_LEN, "added padding is less than one full frame");

			// SAFETY: as explained above, this is safe
			extend_unchecked(&mut dest, frame as *const u8, non_padding_bytes);
		})?;
	}

	debug_assert!(frames_iter.bytes.is_empty(), "all bytes were consumed");
	debug_assert_eq!(capacity, dest.capacity(), "allocated enough capacity");
	debug_assert_eq!(capacity, dest.len(), "all allocated capacity is used");

	Ok(dest)
}

#[derive(Debug, ::thiserror::Error)]
pub enum DecodeError {
	#[error("invalid length")]
	InvalidLength,
	#[error("invalid character")]
	InvalidChar
}

#[repr(transparent)]
struct ChunkedSlice<'h, const N: usize> {
	bytes: &'h [u8]
}

impl<'h, const N: usize> ChunkedSlice<'h, N> {
	/// Takes N bytes off the front, returning that front slice, and saving the
	/// rest in `self`.
	///
	/// # Safety
	///
	/// `self.bytes` must have `N` or more bytes left in it,
	/// otherwise invalid memory will be copied from.
	unsafe fn next_frame_unchecked(&mut self) -> &[u8; N] {
		debug_assert!(self.bytes.len() >= N, "enough bytes left to form another whole frame");

		let self_ptr = self.bytes as *const [u8] as *const u8;
		let self_len = self.bytes.len();

		// new slice
		let new_slice = &*(self_ptr as *const [u8; N]);

		// new ptr to self (with N bytes removed from front)
		// SAFETY: see function doc comment. Caller asserts self has at least N bytes and
		// `self_len - N` and `self_ptr.add(N)` is correct because we just took N bytes out above.
		let slice_ptr = slice::from_raw_parts(self_ptr.add(N), self_len - N);
		self.bytes = slice_ptr;

		new_slice
	}

	/// Consumes self, takes the remainder slice, copies it into a temporary
	/// buffer of length `N`, and calls the function with this buffer. Returns
	/// the amount of bytes in that buffer that aren't padding (ie. the amount of
	/// bytes that are actual data bytes).
	///
	/// # Safety
	///
	/// `self.bytes` must have N or less bytes left in it,
	/// otherwise invalid memory will be written to.
	unsafe fn with_remainder_unchecked<F>(self, mut f: F) -> usize
	where
		F: FnMut(&[u8; N])
	{
		let len = self.bytes.len();
		debug_assert!(len < N, "less than a whole frame remaining");

		// temp buffer of correct length, to add padding
		let mut slice = [0u8; N];

		// ptr to self
		let self_ptr = self.bytes as *const [u8] as *const u8;
		// ptr to temp buffer
		let slice_ptr = &mut slice as *mut [u8] as *mut u8;

		// SAFETY: slice in self has n bytes remaining (match branch condition),
		// and we've tested that n is less than N. therefore, the amount of
		// bytes copied will be the correct amount, and always fit in the temp buffer.
		ptr::copy_nonoverlapping(self_ptr, slice_ptr, len);

		f(&slice);
		len
	}
}

unsafe fn encode_frame(frame: &[u8; BINARY_FRAME_LEN], dest: &mut Vec<u8>) {
	let mut int = u32::from_be_bytes(*frame) as usize;

	let byte5 = int % TABLE_ENCODER_LEN;
	int /= TABLE_ENCODER_LEN;

	let byte4 = int % TABLE_ENCODER_LEN;
	int /= TABLE_ENCODER_LEN;

	let byte3 = int % TABLE_ENCODER_LEN;
	int /= TABLE_ENCODER_LEN;

	let byte2 = int % TABLE_ENCODER_LEN;
	int /= TABLE_ENCODER_LEN;

	let byte1 = int;

	debug_assert!(int % TABLE_ENCODER_LEN == int, "no remaining/unused byte information");
	debug_assert!(int / TABLE_ENCODER_LEN == 0, "no remaining/unused byte information");

	// SAFETY: these are calculated by modulo TABLE_ENCODER_LEN, which
	// guarantees the numbers are 0 <= n < TABLE_ENCODER_LEN, which won't overflow
	let encoded_frame: [u8; STRING_FRAME_LEN] = unsafe { [
		*TABLE_ENCODER.get_unchecked(byte1),
		*TABLE_ENCODER.get_unchecked(byte2),
		*TABLE_ENCODER.get_unchecked(byte3),
		*TABLE_ENCODER.get_unchecked(byte4),
		*TABLE_ENCODER.get_unchecked(byte5),
	] };

	extend_unchecked_const(dest, &encoded_frame);
}

unsafe fn decode_frame<F>(frame: &[u8; STRING_FRAME_LEN], f: F) -> Result<(), DecodeError>
where
	F: FnOnce(&[u8; BINARY_FRAME_LEN])
{
	let [byte1, byte2, byte3, byte4, byte5] = *frame;

	// SAFETY: 0 <= n < 256 is always true for a u8, and TABLE_DECODER is len 256,
	// so this is safe.
	// Additionally, if this comes back as Some from TABLE_DECODER, it is guaranteed
	// to be 0 <= n <= 84, since there are no Some(n) outside this range.
	let Some(byte1) = *TABLE_DECODER.get_unchecked(byte1 as usize) else {
		return Err(DecodeError::InvalidChar)
	};
	let Some(byte2) = *TABLE_DECODER.get_unchecked(byte2 as usize) else {
		return Err(DecodeError::InvalidChar)
	};
	let Some(byte3) = *TABLE_DECODER.get_unchecked(byte3 as usize) else {
		return Err(DecodeError::InvalidChar)
	};
	let Some(byte4) = *TABLE_DECODER.get_unchecked(byte4 as usize) else {
		return Err(DecodeError::InvalidChar)
	};
	let Some(byte5) = *TABLE_DECODER.get_unchecked(byte5 as usize) else {
		return Err(DecodeError::InvalidChar)
	};

	let mut int = byte1 as u32;

	int *= TABLE_ENCODER_LEN as u32;
	int += byte2 as u32;

	int *= TABLE_ENCODER_LEN as u32;
	int += byte3 as u32;

	int *= TABLE_ENCODER_LEN as u32;
	int += byte4 as u32;

	int *= TABLE_ENCODER_LEN as u32;
	int += byte5 as u32;

	let decoded_frame = u32::to_be_bytes(int);
	f(&decoded_frame);

	Ok(())
}

// maybe this has monomorphisation benefit? dunno
#[inline(always)]
unsafe fn extend_unchecked_const<const N: usize>(vec: &mut Vec<u8>, bytes_ptr: *const [u8; N]) {
	debug_assert!(vec.len() + N <= vec.capacity(), "enough allocated capacity in vec to manually append to");

	let len = vec.len();
	let dest_ptr = vec.as_mut_ptr().add(len);
	let bytes_ptr = bytes_ptr as *const u8;

	ptr::copy_nonoverlapping(bytes_ptr, dest_ptr, N);
	vec.set_len(len + N);
}

#[inline(always)]
unsafe fn extend_unchecked(vec: &mut Vec<u8>, bytes_ptr: *const u8, n: usize) {
	debug_assert!(vec.len() + n <= vec.capacity(), "enough allocated capacity in vec to manually append to");

	let len = vec.len();
	let dest_ptr = vec.as_mut_ptr().add(len);

	ptr::copy_nonoverlapping(bytes_ptr, dest_ptr, n);
	vec.set_len(len + n);
}

#[cfg(test)]
mod tests {
	use super::*;
	use ::rand::{ Rng, thread_rng };

	#[test]
	fn provided_test_case() {
		let bytes: &[u8] = &[
			0x86, 0x4f, 0xd2, 0x6f,
			0xb5, 0x59, 0xf7, 0x5b
		];
		let encoded = "HelloWorld";

		assert_eq!(encoded, encode_z85(bytes));
		assert_eq!(bytes, decode_z85(encoded.as_bytes()).expect("provided test case decodes properly"));
	}

	#[test]
	fn randomised() {
		// (bytes_len, encoded_len)
		// (expected_input_len, expected_output_len)
		let expected_lengths = [
			(0usize, 0usize),
			(1, 6),
			(2, 6),
			(3, 6),
			(4, 5),
			(5, 11),
			(6, 11),
			(7, 11),
			(8, 10),
			(9, 16),
			(10, 16),
			(11, 16),
			(12, 15),
			(13, 21),
			(14, 21),
			(15, 21),
			(16, 20),
			(17, 26),
			(18, 26),
			(19, 26),
			(20, 25),

			(50, 66),
			(100, 125),
			(500, 625),
			(1000, 1250),
			(100_000, 125_000),
			(1_000_000, 1_250_000),
		];
		let mut rng = thread_rng();

		for (expected_input_len, expected_output_len) in expected_lengths {
			for _ in 0usize..5 {
				let mut original_input = vec![0u8; expected_input_len];
				rng.fill(&mut *original_input);
				assert_eq!(original_input.len(), expected_input_len);

				let encoded = encode_z85(&original_input);
				assert_eq!(encoded.len(), expected_output_len);

				let decoded = decode_z85(encoded.as_bytes())
					.expect("can round trip decode just encoded data");
				assert_eq!(decoded.len(), expected_input_len);

				assert_eq!(original_input, decoded);

				// this is enforced by debug_assert! in the code, so this already
				// is validated if tests are run in debug, but still,
				assert_eq!(encoded.len(), encoded.capacity());
				assert_eq!(decoded.len(), decoded.capacity());
			}
		}
	}

	#[test]
	fn z85_crate_nonpadded_compat() {
		// this should work, since when bytes length is a multiple of 4
		// we don't add any padding characters and `z85` doesn't add any
		// either, meaning in this situation our impls are cross compatible

		let mut rng = thread_rng();

		let mut bytes = vec![0u8; 1000];
		rng.fill(&mut *bytes);
		let bytes = &*bytes;

		let wiwi_encoded = encode_z85(bytes);
		let z85_encoded = ::z85::encode(bytes);
		assert_eq!(wiwi_encoded, z85_encoded);

		let wiwi_decoded_z85 = decode_z85(z85_encoded.as_bytes())
			.expect("wiwi can decode z85");
		let z85_decoded_wiwi = ::z85::decode(wiwi_encoded.as_bytes())
			.expect("z85 can decode wiwi");

		assert_eq!(wiwi_decoded_z85, z85_decoded_wiwi);
	}
}
